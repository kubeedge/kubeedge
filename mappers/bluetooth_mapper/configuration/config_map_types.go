/*
Copyright 2019 The KubeEdge Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package configuration

import (
	"encoding/json"
	"io/ioutil"
)

// Bluetooth Protocol Operation type
const (
	BluetoothAdd      string = "Add"
	BluetoothSubtract string = "Subtract"
	BluetoothMultiply string = "Multiply"
	BluetoothDivide   string = "Divide"
)

// Twin provides a logical representation of control properties (writable properties in the
// device model). The properties can have a Desired state and a Reported state. The cloud configures
// the `Desired`state of a device property and this configuration update is pushed to the edge node.
// The mapper sends a command to the device to change this property value as per the desired state .
// It receives the `Reported` state of the property once the previous operation is complete and sends
// the reported state to the cloud. Offline device interaction in the edge is possible via twin
// properties for control/command operations.
type Twin struct {
	// Required: The property name for which the desired/reported values are specified.
	// This property should be present in the device model.
	PropertyName string `json:"propertyName,omitempty"`
	// Required: the desired property value.
	Desired TwinProperty `json:"desired,omitempty"`
	// Required: the reported property value.
	Reported TwinProperty `json:"reported,omitempty"`
}

// TwinProperty represents the device property for which an Expected/Actual state can be defined.
type TwinProperty struct {
	// Required: The value for this property.
	Value string `json:"value,"`
	// Additional metadata like timestamp when the value was reported etc.
	// +optional
	Metadata map[string]string `json:"metadata,omitempty"`
}

// DataProperty represents the device property for external use.
type DataProperty struct {
	// Required: The property name for which should be processed by external apps.
	// This property should be present in the device model.
	PropertyName string `json:"propertyName,omitempty"`
	// Additional metadata like timestamp when the value was reported etc.
	// +optional
	Metadata map[string]string `json:"metadata,omitempty"`
}

// DeviceData reports the device's time-series data to edge MQTT broker.
// These data should not be processed by edgecore. Instead, they can be process by
// third-party data-processing apps like EMQX kuiper.
type DeviceData struct {
	// Required: A list of data properties, which are not required to be processed by edgecore
	DataProperties []DataProperty `json:"dataProperties,omitempty"`
	// Topic used by mapper, all data collected from dataProperties
	// should be published to this topic,
	// the default value is $ke/events/device/+/data/update
	// +optional
	DataTopic string `json:"dataTopic,omitempty"`
}

// DeviceProfile is structure to store in configMap. These types would be consumed by mappers to marshal / unmarshal the device profile json
type DeviceProfile struct {
	// DeviceInstances is used to store list of all devices.
	DeviceInstances []*DeviceInstance `json:"deviceInstances,omitempty"`
	// DeviceModels is used to store list of all DeviceModels referenced by DeviceInstances
	DeviceModels []*DeviceModel `json:"deviceModels,omitempty"`
	// Protocols is list of all protocols used by DeviceInstances
	Protocols []*Protocol `json:"protocols,omitempty"`
}

// DeviceInstance is structure to store device in deviceProfile.json in configmap
type DeviceInstance struct {
	// ID is deviceInstance ID
	ID string `json:"id,omitempty"`
	// Name is deviceInstance name
	Name string `json:"name,omitempty"`
	// Protocol is deviceInstance protocol name. It is generated by deviceController
	Protocol string `json:"protocol,omitempty"`
	// Model is deviceInstance model name
	Model string `json:"model,omitempty"`
	// A list of device twins containing desired/reported desired/reported values of twin properties..
	// Optional: A passive device won't have twin properties and this list could be empty.
	// +optional
	Twins []Twin `json:"twins,omitempty"`
	// A list of data properties, which are not required to be processed by edgecore
	// +optional
	DataProperties []DataProperty `json:"dataProperties,omitempty"`
	// Topic used by mapper, all data collected from dataProperties
	// should be published to this topic,
	// the default value is $ke/events/device/+/data/update
	// +optional
	DataTopic string `json:"dataTopic,omitempty"`
	// PropertyVisitors is list of all PropertyVisitors in DeviceModels
	PropertyVisitors []*PropertyVisitor `json:"propertyVisitors,omitempty"`
}

// DeviceModel is structure to store deviceModel in deviceProfile.json in configmap
type DeviceModel struct {
	// Name is DeviceModel name
	Name string `json:"name,omitempty"`
	// Description is DeviceModel description
	Description string `json:"description,omitempty"`
	// Properties is list of DeviceModel properties
	Properties []*Property `json:"properties,omitempty"`
}

// Property is structure to store deviceModel property
type Property struct {
	// Name is Property name
	Name string `json:"name,omitempty"`
	// DataType is property dataType
	DataType string `json:"dataType,omitempty"`
	// Description is property description
	Description string `json:"description,omitempty"`
	// AccessMode is property accessMode
	AccessMode string `json:"accessMode,omitempty"`
	// DefaultValue is property defaultValue
	DefaultValue interface{} `json:"defaultValue,omitempty"`
	// Minimum is property minimum value in case of int, double and float
	Minimum interface{} `json:"minimum,omitempty"`
	// Maximum is property maximum value in case of int, double and float
	Maximum interface{} `json:"maximum,omitempty"`
	// Unit is unit of measurement
	Unit string `json:"unit,omitempty"`
}

// Protocol is structure to store protocol in deviceProfile.json in configmap
type Protocol struct {
	// Name is protocol name
	Name string `json:"name,omitempty"`
	// Protocol is protocol name defined in deviceInstance. It is generated by deviceController
	Protocol string `json:"protocol,omitempty"`
	// ProtocolConfig is protocol config
	ProtocolConfig interface{} `json:"protocolConfig"`
	// ProtocolCommonConfig is common part of protocol config
	ProtocolCommonConfig interface{} `json:"protocolCommonConfig"`
}

// PropertyVisitor is structure to store propertyVisitor in deviceProfile.json in configmap
type PropertyVisitor struct {
	// Name is propertyVisitor name
	Name string `json:"name,omitempty"`
	// PropertyName is name of property it is mapped to
	PropertyName string `json:"propertyName,omitempty"`
	// ModelName is deviceModel name
	ModelName string `json:"modelName,omitempty"`
	// Protocol is protocol of propertyVisitor
	Protocol string `json:"protocol,omitempty"`
	// Define how frequent mapper will report the value.
	ReportCycle int64 `json:"reportCycle,omitempty"`
	// Define how frequent mapper will collect from device.
	CollectCycle int64 `json:"collectCycle,omitempty"`
	// Customized values for visitor of provided protocols
	// +optional
	CustomizedValues interface{} `json:"customizedValues,omitempty"`
	// VisitorConfig is property visitor configuration
	VisitorConfig interface{} `json:"visitorConfig,omitempty"`
}

// Common visitor configurations for bluetooth protocol
type VisitorConfigBluetooth struct {
	// Required: Unique ID of the corresponding operation
	CharacteristicUUID string `json:"characteristicUUID,omitempty"`
	// Responsible for converting the data coming from the platform into a form that is understood by the bluetooth device
	// For example: "ON":[1], "OFF":[0]
	//+optional
	DataWriteToBluetooth map[string][]byte `json:"dataWrite,omitempty"`
	// Responsible for converting the data being read from the bluetooth device into a form that is understandable by the platform
	//+optional
	BluetoothDataConverter BluetoothReadConverter `json:"dataConverter,omitempty"`
}

// Specifies the operations that may need to be performed to convert the data
type BluetoothReadConverter struct {
	// Required: Specifies the start index of the incoming byte stream to be considered to convert the data.
	// For example: start-index:2, end-index:3 concatenates the value present at second and third index of the incoming byte stream. If we want to reverse the order we can give it as start-index:3, end-index:2
	StartIndex int `json:"startIndex,omitempty"`
	// Required: Specifies the end index of incoming byte stream to be considered to convert the data
	// the value specified should be inclusive for example if 3 is specified it includes the third index
	EndIndex int `json:"endIndex,omitempty"`
	// Refers to the number of bits to shift left, if left-shift operation is necessary for conversion
	// +optional
	ShiftLeft uint `json:"shiftLeft,omitempty"`
	// Refers to the number of bits to shift right, if right-shift operation is necessary for conversion
	// +optional
	ShiftRight uint `json:"shiftRight,omitempty"`
	// Specifies in what order the operations(which are required to be performed to convert incoming data into understandable form) are performed
	//+optional
	OrderOfOperations []BluetoothOperations `json:"orderOfOperations,omitempty"`
}

// Specify the operation that should be performed to convert incoming data into understandable form
type BluetoothOperations struct {
	// Required: Specifies the operation to be performed to convert incoming data
	BluetoothOperationType string `json:"operationType,omitempty"`
	// Required: Specifies with what value the operation is to be performed
	BluetoothOperationValue float64 `json:"operationValue,omitempty"`
}

//ReadFromConfigMap is used to load the information from the configmaps that are provided from the cloud
func (deviceProfile *DeviceProfile) ReadFromConfigMap() error {
	jsonFile, err := ioutil.ReadFile(ConfigMapPath)
	if err != nil {
		return err
	}
	err = json.Unmarshal(jsonFile, deviceProfile)
	if err != nil {
		return err
	}
	return nil
}
